# LMS Microservices - GitHub Actions CI/CD Pipeline
# Deploys to Azure AKS using Azure Container Registry
# Secrets managed via Azure Key Vault

name: Build and Deploy to AKS

on:
  push:
    branches:
      - main
      - master
    paths:
      - 'lms_micro_services/**'
      - '.github/workflows/deploy.yml'
  pull_request:
    branches:
      - main
      - master
    paths:
      - 'lms_micro_services/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - development

env:
  # Azure Configuration
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  RESOURCE_GROUP: rg-lms-prod-lms-rbmfy1
  
  # Azure Container Registry
  ACR_NAME: acrlmsprodlmsrbmfy1
  ACR_LOGIN_SERVER: acrlmsprodlmsrbmfy1.azurecr.io
  
  # Azure Kubernetes Service
  AKS_CLUSTER: aks-lms-prod
  AKS_NAMESPACE: lms-production
  
  # Image Tags
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # ============================================
  # Job 1: Build and Push Docker Images
  # ============================================
  build:
    name: Build and Push Images
    runs-on: ubuntu-latest
    
    outputs:
      image_tag: ${{ steps.set-tag.outputs.tag }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set image tag
        id: set-tag
        run: echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
      
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Login to Azure Container Registry
        run: |
          az acr login --name ${{ env.ACR_NAME }}
      
      # Build Auth Service
      - name: Build and Push Auth Service
        run: |
          docker build -t ${{ env.ACR_LOGIN_SERVER }}/auth-service:${{ env.IMAGE_TAG }} \
            -t ${{ env.ACR_LOGIN_SERVER }}/auth-service:latest \
            ./lms_micro_services/auth-service
          docker push ${{ env.ACR_LOGIN_SERVER }}/auth-service:${{ env.IMAGE_TAG }}
          docker push ${{ env.ACR_LOGIN_SERVER }}/auth-service:latest
      
      # Build Content Service
      - name: Build and Push Content Service
        run: |
          docker build -t ${{ env.ACR_LOGIN_SERVER }}/content-service:${{ env.IMAGE_TAG }} \
            -t ${{ env.ACR_LOGIN_SERVER }}/content-service:latest \
            ./lms_micro_services/content-service
          docker push ${{ env.ACR_LOGIN_SERVER }}/content-service:${{ env.IMAGE_TAG }}
          docker push ${{ env.ACR_LOGIN_SERVER }}/content-service:latest
      
      # Build Assignment Service
      - name: Build and Push Assignment Service
        run: |
          docker build -t ${{ env.ACR_LOGIN_SERVER }}/assignment-service:${{ env.IMAGE_TAG }} \
            -t ${{ env.ACR_LOGIN_SERVER }}/assignment-service:latest \
            ./lms_micro_services/assignment-service
          docker push ${{ env.ACR_LOGIN_SERVER }}/assignment-service:${{ env.IMAGE_TAG }}
          docker push ${{ env.ACR_LOGIN_SERVER }}/assignment-service:latest
      
      # Build Frontend Admin
      - name: Build and Push Frontend Admin
        run: |
          docker build -t ${{ env.ACR_LOGIN_SERVER }}/frontend-admin:${{ env.IMAGE_TAG }} \
            -t ${{ env.ACR_LOGIN_SERVER }}/frontend-admin:latest \
            ./lms_micro_services/frontend-admin
          docker push ${{ env.ACR_LOGIN_SERVER }}/frontend-admin:${{ env.IMAGE_TAG }}
          docker push ${{ env.ACR_LOGIN_SERVER }}/frontend-admin:latest
      
      # Build Frontend Student
      - name: Build and Push Frontend Student
        run: |
          docker build -t ${{ env.ACR_LOGIN_SERVER }}/frontend-student:${{ env.IMAGE_TAG }} \
            -t ${{ env.ACR_LOGIN_SERVER }}/frontend-student:latest \
            ./lms_micro_services/frontend-student
          docker push ${{ env.ACR_LOGIN_SERVER }}/frontend-student:${{ env.IMAGE_TAG }}
          docker push ${{ env.ACR_LOGIN_SERVER }}/frontend-student:latest
      
      # Build Frontend Teacher
      - name: Build and Push Frontend Teacher
        run: |
          docker build -t ${{ env.ACR_LOGIN_SERVER }}/frontend-teacher:${{ env.IMAGE_TAG }} \
            -t ${{ env.ACR_LOGIN_SERVER }}/frontend-teacher:latest \
            ./lms_micro_services/frontend-teacher
          docker push ${{ env.ACR_LOGIN_SERVER }}/frontend-teacher:${{ env.IMAGE_TAG }}
          docker push ${{ env.ACR_LOGIN_SERVER }}/frontend-teacher:latest

  # ============================================
  # Job 2: Deploy to AKS
  # ============================================
  deploy:
    name: Deploy to AKS
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER }} \
            --overwrite-existing
      
      - name: Create Namespace if not exists
        run: |
          kubectl create namespace ${{ env.AKS_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Create/Update ConfigMap
        run: |
          kubectl apply -f AzureOperation/Phase2-AppDeployment/kubernetes/01-configmap.yaml -n ${{ env.AKS_NAMESPACE }}
      
      - name: Install Secrets Store CSI Driver
        run: |
          # Add CSI Secrets Store Provider for Azure
          helm repo add csi-secrets-store-provider-azure https://azure.github.io/secrets-store-csi-driver-provider-azure/charts
          helm repo update
          
          # Install if not already installed
          helm upgrade --install csi-secrets-store-provider-azure \
            csi-secrets-store-provider-azure/csi-secrets-store-provider-azure \
            --namespace kube-system \
            --set secrets-store-csi-driver.syncSecret.enabled=true
      
      - name: Apply SecretProviderClass
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: secrets-store.csi.x-k8s.io/v1
          kind: SecretProviderClass
          metadata:
            name: azure-keyvault-secrets
            namespace: ${{ env.AKS_NAMESPACE }}
          spec:
            provider: azure
            parameters:
              usePodIdentity: "false"
              useVMManagedIdentity: "true"
              userAssignedIdentityID: ""
              keyvaultName: kv-lms-prod-lms-rbmfy1
              objects: |
                array:
                  - |
                    objectName: postgres-password
                    objectType: secret
                  - |
                    objectName: cosmos-primary-key
                    objectType: secret
                  - |
                    objectName: storage-account-key
                    objectType: secret
                  - |
                    objectName: jwt-secret-key
                    objectType: secret
              tenantId: ${{ secrets.AZURE_TENANT_ID }}
            secretObjects:
              - secretName: lms-secrets
                type: Opaque
                data:
                  - objectName: postgres-password
                    key: POSTGRES_PASSWORD
                  - objectName: cosmos-primary-key
                    key: COSMOS_PRIMARY_KEY
                  - objectName: storage-account-key
                    key: STORAGE_ACCOUNT_KEY
                  - objectName: jwt-secret-key
                    key: JWT_SECRET_KEY
          EOF
      
      - name: Update Deployment Image Tags
        run: |
          # Update image tags in deployment files
          cd AzureOperation/Phase2-AppDeployment/kubernetes
          
          # Replace image references with new tags
          for file in 03-auth-service.yaml 04-content-service.yaml 05-assignment-service.yaml 06-frontends.yaml; do
            if [ -f "$file" ]; then
              # Update ACR name if needed
              sed -i "s|acrlmslmsdxdfyl.azurecr.io|${{ env.ACR_LOGIN_SERVER }}|g" "$file"
              # Update image tag
              sed -i "s|:latest|:${{ needs.build.outputs.image_tag }}|g" "$file"
            fi
          done
      
      - name: Deploy Backend Services
        run: |
          kubectl apply -f AzureOperation/Phase2-AppDeployment/kubernetes/03-auth-service.yaml -n ${{ env.AKS_NAMESPACE }}
          kubectl apply -f AzureOperation/Phase2-AppDeployment/kubernetes/04-content-service.yaml -n ${{ env.AKS_NAMESPACE }}
          kubectl apply -f AzureOperation/Phase2-AppDeployment/kubernetes/05-assignment-service.yaml -n ${{ env.AKS_NAMESPACE }}
      
      - name: Deploy Frontend Services
        run: |
          kubectl apply -f AzureOperation/Phase2-AppDeployment/kubernetes/06-frontends.yaml -n ${{ env.AKS_NAMESPACE }}
      
      - name: Deploy Ingress
        run: |
          kubectl apply -f AzureOperation/Phase2-AppDeployment/kubernetes/07-ingress.yaml -n ${{ env.AKS_NAMESPACE }}
      
      - name: Deploy Horizontal Pod Autoscalers
        run: |
          kubectl apply -f AzureOperation/Phase2-AppDeployment/kubernetes/08-hpa-autoscaling.yaml -n ${{ env.AKS_NAMESPACE }}
      
      - name: Wait for Deployments
        run: |
          echo "Waiting for deployments to be ready..."
          kubectl rollout status deployment/auth-service -n ${{ env.AKS_NAMESPACE }} --timeout=300s || true
          kubectl rollout status deployment/content-service -n ${{ env.AKS_NAMESPACE }} --timeout=300s || true
          kubectl rollout status deployment/assignment-service -n ${{ env.AKS_NAMESPACE }} --timeout=300s || true
      
      - name: Get Deployment Status
        run: |
          echo "=== Deployment Status ==="
          kubectl get deployments -n ${{ env.AKS_NAMESPACE }}
          echo ""
          echo "=== Pods Status ==="
          kubectl get pods -n ${{ env.AKS_NAMESPACE }}
          echo ""
          echo "=== Services ==="
          kubectl get services -n ${{ env.AKS_NAMESPACE }}
          echo ""
          echo "=== Ingress ==="
          kubectl get ingress -n ${{ env.AKS_NAMESPACE }}

  # ============================================
  # Job 3: Post-Deployment Verification
  # ============================================
  verify:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: deploy
    
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER }} \
            --overwrite-existing
      
      - name: Health Check
        run: |
          echo "=== Running Health Checks ==="
          
          # Get ingress IP
          INGRESS_IP=$(kubectl get ingress -n ${{ env.AKS_NAMESPACE }} -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          
          if [ -n "$INGRESS_IP" ]; then
            echo "Ingress IP: $INGRESS_IP"
            
            # Test API Gateway health
            echo "Testing API Gateway..."
            curl -s -o /dev/null -w "%{http_code}" "http://$INGRESS_IP/api/health" || echo "API Gateway not responding"
          else
            echo "Ingress IP not yet assigned. Check back later."
          fi
          
          # Show pod logs if any pods are failing
          echo ""
          echo "=== Checking for failing pods ==="
          FAILING_PODS=$(kubectl get pods -n ${{ env.AKS_NAMESPACE }} --field-selector=status.phase!=Running,status.phase!=Succeeded -o name 2>/dev/null || echo "")
          
          if [ -n "$FAILING_PODS" ]; then
            echo "Found failing pods:"
            echo "$FAILING_PODS"
            for pod in $FAILING_PODS; do
              echo ""
              echo "--- Logs for $pod ---"
              kubectl logs $pod -n ${{ env.AKS_NAMESPACE }} --tail=50 || true
            done
          else
            echo "All pods are running successfully!"
          fi

  # ============================================
  # Job 4: Notification (Optional)
  # ============================================
  notify:
    name: Send Notification
    runs-on: ubuntu-latest
    needs: [build, deploy, verify]
    if: always()
    
    steps:
      - name: Deployment Summary
        run: |
          echo "=========================================="
          echo "       DEPLOYMENT SUMMARY"
          echo "=========================================="
          echo ""
          echo "Repository: ${{ github.repository }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "Actor: ${{ github.actor }}"
          echo ""
          echo "Build Status: ${{ needs.build.result }}"
          echo "Deploy Status: ${{ needs.deploy.result }}"
          echo "Verify Status: ${{ needs.verify.result }}"
          echo ""
          echo "Image Tag: ${{ github.sha }}"
          echo "ACR: ${{ env.ACR_LOGIN_SERVER }}"
          echo "AKS Cluster: ${{ env.AKS_CLUSTER }}"
          echo "Namespace: ${{ env.AKS_NAMESPACE }}"
          echo "=========================================="
